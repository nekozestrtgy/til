; = 「。」
セミコロンは「。」の役割。文の終わりに必ずつける。抜けがあると、処理が行われなくなる。

printlnは、プリントライン

### データ型
String 文字(Sは大文字)
int 数字(iは小文字)
double 小数
boolean 真偽値

### 変数の定義

```
(データ型) (変数名);
```
例
```
int number;
String name;
```

変数の定義と同時に、値を代入することもできる。これを、変数の初期化と言う。
```
int number = 3;
String name = "Hello World";
```

変数の値を上書きするときは、データ型をつけない。データ型をつけると、新しい変数を定義することになってしまう。同じ名前の変数は定義できない。
```
//good
int number = 3;
number = 5;

//error
int number = 3;
int number = 5;
```

変数名には、キャメルケースを用いる。
```
//good
userName

//error or bad
1name 数字開始
user_name スネークケース
namae ローマ字
名前 日本語
```

変数の定義時に値を代入しなかった場合、下記のように初期値が設定される。
```
String → null
int → 0
double → 0.0
boolean → false
```


### 計算
```
int number = 1;

//以下全部同じ意味
number = number + 1;
number += 1;
number++; //足す値が1の時はこう書ける。
```

int型同士の計算は、int型で出力される。
```
println(5/2);
//→2
```
int型とdouble型だと、double型で出力される。
```
pringln(5.0/2);
//→2.5
```

### キャスト
キャストとは、強制的に型変換を行うこと。
```
println((double)7 / 2;
//→3.5　double型で出力される。
```
この場合、7のデータ型がdoubleに変換され、double型とint型の計算で、double型が出力される。

### 比較演算子
```
x == y →xとyが等しい時true
x != y →xとyが等しくない時true
x >= y →xがy以上の時true
```
`&&`や`||`など、複雑な論理演算子を用いた範囲の時は、図で数直線を書いて考えるとわかりやすい。

### 条件分岐
```
if (条件) {
  (処理);
}
```
ブロック`{}`の後ろには、`;`不要

### switch文
`xが２と一致する時`などの条件を使用する時に、if文より簡潔に記述ができる。
```
switch (条件) {
  case 値1:
    処理;
    break;
  case 値2:
    処理;
    break;
  case 値3:
    処理;
    break;
  default:
    処理;
    break;
}
```
値の後ろには`:`を忘れない。また処理の後には`break`を書かないと次の処理が実行されてしまうので忘れない。
`default`は、どの`case`にも当てはまらなかった場合に実行される。


### 繰り返し
```
while (条件) {
  処理;
}
```
```
for ((変数の初期化);(条件);(変数の更新)) {
  処理;
}
```
最後の`変数の更新`の後ろには、`;`をつけない。

`continue`特定の場合のみ処理をスキップ、'break'は強制終了

### 配列
```
int[] numbers = {1,2,3};
String[] names = {"john","ken","mika"};
println(names[0]); //→john
println(names.length); //→3
```
配列用のfor文は以下のように書ける
```
for ((データ型) (変数名): 配列名) {
  処理;
}
```
配列の要素が、for文の条件で新しく定義された変数にひとつひとつ代入され、繰り返し処理されていく。

### クラス
定義
```クラス名.java
class （クラス名）　{
  //ここにメソッドやフィールドを定義
}
```
クラス名は必ず大文字から始める。
クラス名に関係なく、`main`メソッドが呼ばれる。

カプセル化
```
クラスの外でも使用できるもの → public
クラスの外で使用して欲しくないもの → private
//privateを使ったものは、カプセル化される。
```

ゲッター
```
public (戻り値のデータ型) get(フィールド名)() {
  return this.(フィールド名);
}
//これでクラス外からも安全にカプセル化されたフィールドの値を取得できる。
```

セッター



コンストラクタ=newで新しいインスタンスを生成した時に自動で呼び出される特別なメソッド
定義
```
class (クラス名) {
  （クラス名）(仮引数) {
    //インスタンスの生成時に行いたい処理
  }
}
//コンストラクタ名＝クラス名、void含め戻り値は書かないのがルール
```
```
this(引数);
//コンストラクタを呼び出すことができる。コンストラクタのオーバーロード時に便利。
//this()は、コンストラクタの先頭でしか呼び出せないので注意。
```

クラスフィールドの定義
```
public static (データ型) (変数名)
//クラスフィールドにはstaticをつける。

//初期値を設定する場合は、以下。
public static (データ型) (変数名) = 初期値;
```

クラスフィールドへのアクセス
```
(クラス名).(フィールド名)
```

クラスメソッドの定義
```
public static (戻り値のデータ型) (メソッド名)(仮引数) {
  //処理
}
//クラスメソッドにはstaticをつける。
```
メソッド名の後ろで、仮引数を使用する場合は`(データ型)(変数名)`のかたちで定義する。
戻り値がない場合は、戻り値のデータ型を`void`とする。
メソッド名が同じでも、引数の有無や定義が異なれば、同名のメソッドを定義することは可能＝オーバーロード
クラスフィールドの場合は、`static`をつける。インスタンスフィールドの場合は、つけない。クラスフィールドは、クラスに属する。

インスタンスの生成(と変数への代入)
```
(クラス型) (変数名) = new (クラス名)(引数);
//引数は、コンストラクタに渡される。
```

インスタンスメソッドの呼び出し
```
(インスタンス名).(メソッド名)(引数)
```

インスタンスフィールドの定義
```
public （データ型） (変数名)
```

インスタンスフィールドへのアクセス
```
(インスタンス).(フィールド名)(引数)
```

this メソッド内でインスタンスフィールドにアクセスする際に使用。
```
class Person {
  public String name;
  public void hello() {
    System.out.println("こんにちは、私は" + this.name + "です。");
  }
}
//thisは、helloメソッドを呼び出したインスタンスに置き換えられる。
```

外部ライブラリの読み込み
```
import （外部ライブラリ）;
```
